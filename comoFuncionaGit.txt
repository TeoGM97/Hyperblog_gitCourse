FLUJO DE TRABAJO:
Cuando doy git init en una carpeta, se crea la carpeta .git y se crea el estado de staging (area de memoria RAM)
Cuando doy git add a un archivo, pasa a estar en un estado de staging y luego commit para que quede en el repositorio que tiene un nombre por defecto: Master
Staging es la memoria ram o estado temporal donde estan los archivos antes de hacerles el commit.
Antes de usar el git add, el archivo esta untracked.
Un archivo modificado lo detecta git, pero no lo considera en un commit hasta que no se agregue con add.
Cuando quiero traer un cambio del repositorio pero no esta en mi carpeta, lo que hago es ir a esa version y usar checkout.
Cuando tengo una version experimental o quiero crear una rama de desarrollo sin que sea la master, o queremos trabajar en dos o mas cosas al mismo tiempo se usan las Ramas o Branches

BRANCHES:
Por defecto estamos en la rama Master en la que podemos tener varias versiones.
A veces es necesario crear otra rama que sale de alguna de las versiones para realizar cambios experimentales o por alguna raz√≥n.
Tambien hay a veces ramas que se crean para la solucion de bugs(bug fixing o hot fix). Luego de crear la solucion, se puede reconectar con la rama actual, lo que se conoce como un merge.
Si quiero agregar cambios hechos en otras ramas a otras, se llama merge tambien.
Se pueden tener tantas ramas y repositorios como quiera.

Cuando se trabaja con un equipo, se neceita un servidor remoto. Git Hub por ejemplo) cuando el commit se hace, se hace un git push para envairlo a este servidor remoto.
Si quiero traer una actualizacion, hago un git fetch para traer al repositorio local. PAra que me copie todo en mis archivos, hago git merge.
Hay un comando que fusiona ambos conceptos que es git pull
